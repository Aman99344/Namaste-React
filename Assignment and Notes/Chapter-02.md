##  What is `NPM`?

npm is a short form of Node Package Manager, which is the world's largest software registry. The open-source web project developers use it from the entire world to share and borrow packages. The npm also acts as a command-line utility for the Node.js project for installing packages in the project, dependency management, and even version management.

##  What is `Parcel/Webpack`? Why do we need it?

Parcel is a bundler.
Parcel optimizes your whole app for production automatically. This includes tree-shaking and minifying your JavaScript, CSS, and HTML, resizing and optimizing images, content hashing, automatic code splitting, and much more.

## What is `.parcel-cache`

It stores information about your project when parcel builds it, so that when it rebuilds, it doesn't have to re-parse and re-analyze everything from scratch. It's a key reason why parcel can be so fast in development mode.


## What is `npx` ?

NPX stands for Node Package eXecute. It is simply an NPM package runner. It allows developers to execute any Javascript Package available on the NPM registry without even installing it. NPX is installed automatically with NPM version 5.2.0 and above.

## What is difference between `dependencies` vs `devDependencies`

dependencies are required for the application to run, while devDependencies are only required for development and testing purposes. When you deploy your application to a production server, you typically only need to include the dependencies.

[Reference](https://www.geeksforgeeks.org/difference-between-dependencies-devdependencies-and-peerdependencies/)


## What is Tree Shaking?

Tree shaking is a term commonly used within a JavaScript context to describe the removal of dead code. It relies on the import and export statements to detect if code modules are exported and imported for use between JavaScript files.

The term "tree shaking" comes from the idea of shaking a tree to remove dead leaves or branches.


## What is Hot Module Replacement?


Hot Module Replacement (HMR) is a feature in modern web development that allows developers to update the application's code in real-time, without having to refresh the browser or lose the application's current state.

With HMR, when a developer makes changes to the application's code, the changes are automatically pushed to the browser and applied to the running application. This means that the application can be updated in real-time, without the need for a full page refresh or losing the current state of the application. This can help to improve development speed and efficiency, as well as reduce the risk of introducing bugs or errors.

HMR is typically implemented using a module bundler, such as Webpack, that is capable of replacing modules in real-time. When a developer saves a file with changes, the module bundler detects the changes and pushes the updated code to the browser using a WebSocket connection. The browser then applies the changes to the running application, without refreshing the page or losing the current state.

HMR can be particularly useful for development workflows that involve frequent code changes or experimentation, such as rapid prototyping or UI design. It can also be helpful for teams that need to collaborate on code changes in real-time, as it allows developers to see each other's changes without having to manually refresh their browsers.

## What is the difference between `package.json` and `package-lock.json`

package.json and package-lock.json are two files commonly used in Node.js projects that are managed using NPM. While both files contain information about the project's dependencies, they serve different purposes.

package.json is a file that is used to define the metadata of the project, such as its name, version, and author, as well as the dependencies required for the project to run. It also includes other configuration options such as scripts, license, and engines. When you run npm install, NPM installs the packages listed in package.json and their dependencies.

package-lock.json, on the other hand, is a file that is automatically generated by NPM when you run npm install. It contains a complete and exact list of all the packages and their dependencies that are installed in the node_modules directory. This means that package-lock.json provides a way to lock down the exact versions of the packages and their dependencies, ensuring that everyone working on the project is using the same version of the packages.

In summary, package.json is used to define the project metadata and list the required dependencies, while package-lock.json is automatically generated to provide a detailed and accurate list of all the installed packages and their dependencies, ensuring consistency across different environments.

##  Why should I not modify `package-lock.json`?

It is a generated file and is not designed to be manually edited. Its purpose is to track the entire tree of dependencies (including dependencies of dependencies) and the exact version of each dependency. You should commit package-lock. json to your code repository.


## What is `node_modules` ? Is it a good idea to push that on git?

node_modules is a directory in a Node.js project that contains all of the dependencies installed for the project using a package manager such as NPM or Yarn. These dependencies are installed based on the information in the package.json file and its associated package-lock.json or yarn.lock file.

It is generally not a good idea to push the node_modules directory to Git for a few reasons:

node_modules directory can be very large, especially for projects with many dependencies, which can bloat the size of your repository and make it slow to clone or pull.

The contents of node_modules are automatically generated by the package manager based on the package.json file and its associated lock file. This means that the same dependencies can be installed on any machine or server by simply running npm install or yarn install. There is no need to include node_modules in the Git repository.

By excluding node_modules from your repository, you keep your Git history clean and focused on your own code changes, which makes it easier to review and merge changes, and reduces the chance of conflicts.

Instead, it is recommended to add node_modules to your .gitignore file, which tells Git to ignore this directory and its contents when tracking changes to the repository.

In summary, it is generally not a good idea to push node_modules to Git. Instead, it is recommended to exclude it from the repository by adding it to .gitignore and allowing the package manager to manage the dependencies during installation.



##  What is the `dist` folder?

The dist folder (short for "distribution") is a folder often used in web development projects to store the files that are ready for deployment or distribution to users. The files in the dist folder are typically the result of a build process, where the original source code is compiled, transpiled, minified, or otherwise optimized for production use.

The exact contents of the dist folder depend on the specific project and build process, but it often includes the following files:

index.html: The main HTML file that is served to users and typically references the other files in the dist folder.
JavaScript files: The compiled and/or minified versions of the project's JavaScript files.
CSS files: The compiled and/or minified versions of the project's CSS files.
Image files: The optimized and/or compressed versions of the project's image files.
By keeping the production-ready files in the dist folder, developers can easily package and deploy the project to a production server or a hosting service, without including the original source code or development tools. This can help improve the performance and security of the website or application by reducing the size of the files that are downloaded by users.

It is common to add the dist folder to the .gitignore file, so that it is not included in the repository and developers must rebuild the distribution files as needed. This helps keep the repository size small and reduces the chance of conflicts due to changes in the distribution files.


## What is `browserlists?

Browserslist is a tool that allows specifying which browsers should be supported in your frontend app by specifying "queries" in a config file. It's used by frameworks/libraries such as React, Angular and Vue, but it's not limited to them.

* 0.2%: All browsers that have at least 0.2% of global market share
* not dead: Exclude browsers without official support in the last 24 months
* not ie <= 11: Exclude IE 11 and older versions
* not op_mini all: Exclude Opera Mini













